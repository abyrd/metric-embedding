#!run me with python

from graphserver.ext.gtfs.gtfsdb import GTFSDatabase
from graphserver.graphdb         import GraphDatabase
from graphserver.core            import Graph, Street, State
from pylab  import *
from numpy  import *
from random import shuffle
import time 
from socket import *
import geotools
from math import ceil
import struct
import pyproj
import sys

reporter = sys.stdout

def cplot(Z) :
    imshow(Z, cmap=cm.gray, origin='bottom')
    levels = array([15, 30, 60, 90])
    CS = contour(Z, levels, linewidths=2)
    clabel(CS, inline=1, fmt='%d', fontsize=14)
    show()

#gtfsdb = GTFSDatabase  ( '../gsdata/bart.gtfsdb' )
#gdb    = GraphDatabase ( '../gsdata/bart.linked.gsdb' )
gtfsdb = GTFSDatabase  ( '../gsdata/trimet_13sep2009.gtfsdb' )
gdb    = GraphDatabase ( '../gsdata/trimet_13sep2009.hpm.linked.gsdb' )
#gdb    = GraphDatabase ( '../gsdata/trimet_13sep2009.nolink.gsdb' )

g  = gdb.incarnate()
t0 = 1253800000

proj = pyproj.Proj( proj='sinu', ellps='WGS84' )
geod = pyproj.Geod( ellps='WGS84' )
min_lon, min_lat, max_lon, max_lat = gtfsdb.extent()
min_lon, min_lat, arc_dist = geod.fwd(min_lon, min_lat, 180+45, 5000)
min_x, min_y = proj( min_lon, min_lat )
proj = pyproj.Proj( proj='sinu', ellps='WGS84', lon_0=min_lon, y_0=-min_y, m=0.1 )

grid = set()
for stop_id, stop_name, lat, lon in gtfsdb.stops() :
    projected   =  proj( lon, lat )
    grid_coords = tuple( [int(round(c / 100)) for c in projected] )
    grid_label  = 'grid-%03i-%03i' % grid_coords
    grid_vertex = g.add_vertex( grid_label )  # returns ref to existing vertex also
    stop_label  = 'sta-' + stop_id
    # used elapsed time edges to link this stop to the appropriate gridpoint
    g.add_edge( grid_label, stop_label, Street('Walk', 100) )     
    g.add_edge( stop_label, grid_label, Street('Walk', 100) ) 
    # cannot save grid vertices here because each one gets its own Python object, even if they have the same c soul
    # thus they make every element in the set unique   
    grid.add( (grid_label, grid_coords) )
    # print grid_vertex, grid_coords

n_gridpoints = len(grid)
grid_labels, grid_coords = zip(*grid)
grid_vertices = [g.get_vertex(e) for e in grid_labels]
print len(grid_labels)
grid_extent = (array(grid_coords).max(axis = 0) + (20, 20)).astype(int)
matrix = empty( (n_gridpoints, n_gridpoints), dtype=float )

for origin_idx, origin_label in enumerate(grid_labels) :
    if reporter : 
        reporter.write( "\rProcessing %i / %i ..." % (origin_idx + 1, n_gridpoints) )
        reporter.flush()
    g.spt_in_place(origin_label, None, State(1, t0))
    for dest_idx, dest_vertex in enumerate(grid_vertices) :
        # first board time should be subtracted here
        if dest_vertex.payload is None :
            delta_t = inf
        else :
            delta_t = dest_vertex.payload.time - t0
        matrix[origin_idx, dest_idx] = delta_t


# precompute distance mask matrix here, use view later
print "precomputing time matrix..."
times_x = arange(grid_extent[0] * 2) - grid_extent[0]
times_y = arange(grid_extent[1] * 2) - grid_extent[1]
times   = sqrt((times_x**2)[:, newaxis] + (times_y ** 2)[newaxis, :]) * 100 / 1.3  # m/sec

temp_grid = empty( grid_extent )
# station at random
for origin_idx in range(n_gridpoints) :
    print origin_idx
    result = matrix[origin_idx]
    grid = ones( grid_extent ) * inf # actually should be set to times from point of departure 
    for dest_idx in range(n_gridpoints) :
        # set up time window
        dest_coords = grid_coords[dest_idx]
        x_1 = round(2 * grid_extent[0] - dest_coords[0])
        x_0 = x_1 - grid_extent[0]
        y_1 = round(2 * grid_extent[1] - dest_coords[1])
        y_0 = y_1 - grid_extent[1]
        add(times[x_0:x_1, y_0:y_1], result[dest_idx], temp_grid)
        minimum(grid, temp_grid, grid)  # destination variabe to do operation in-place
    # cplot((grid / 60).T)
